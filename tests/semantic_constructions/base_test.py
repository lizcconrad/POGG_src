import unittest

# necessary to check MRS isomorphism
from delphin.mrs import is_isomorphic
from delphin.codecs import simplemrs

import POGG.mrs_algebra
import POGG.semantic_constructions.base as base

class TestSEMENTsFromScratch(unittest.TestCase):
    """
    Test functions that SEMENTs from scratch (as opposed to those that compose two SEMENTs into a larger one)

    - Arrange: arrange all necessary preconditions and inputs
    - Act: on the object or method under test
    - Assert: that the expected results have occurred*
    * it is often recommended to have just one assert, but the spirit of Arrange, Act, Assert is that you can have
    more than one assert, provided that you are just confirming multiple aspects of the singular Act
    e.g. checking via separate asserts that a value is above 10 but below 100, but you only set the value via one Act
    """

    def _setUp(self, filepath):
        """
        Custom setup method to read in the hand-validated SEMENT file
        """
        self.SEMENT_file = open(filepath)
        self.validated_SEMENT_str = self.SEMENT_file.read()
        self.validated_SEMENT_obj = simplemrs.decode(self.validated_SEMENT_str)


    def assertSEMENTObject(self, generated_SEMENT_obj):
        """
        Assert SEMENT object generated by test is an instance of SEMENT
        :param generated_SEMENT_obj: SEMENT object generated by test
        :return: None
        """
        # 1. Is it a SEMENT object?
        self.assertIsInstance(generated_SEMENT_obj, POGG.mrs_algebra.SEMENT,
                              "generated_SEMENT_obj is not a SEMENT object.")

    def assertINDEX(self, generated_SEMENT_obj, argX):
        """
        Assert that the INDEX is identified with the appropriate ARG of the key EP. Only for SEMENTs with one EP.
        :param generated_SEMENT_obj: SEMENT object generated by test
        :param argX: ARG of key EP that should be identified with INDEX
        :return: None
        """
        index = generated_SEMENT_obj.index
        argX_value = generated_SEMENT_obj.rels[0].args[argX]
        self.assertEqual(index, argX_value, "INDEX variable ({}) is not equal to {} of key EP ({})".format(index, argX, argX_value))

    # def assertARGEquality(self, generated_SEMENT_obj, first_EP, first_EP_ARG, second_EP, second_EP_ARG):
    #     # get the value of the ARGs that should be equated
    #     first_ARG_val, second_ARG_val= None, None
    #
    #     for ep in generated_SEMENT_obj.rels:
    #         if ep.predicate == first_EP:
    #             # if first_EP_ARG not a key in args dict, then the given ARG isn't in the EP
    #             self.assertIn(first_EP_ARG, ep.args, "{} is not an ARG of the EP {}:\n{}"
    #                           .format(first_EP_ARG, first_EP, ep.args[first_EP_ARG]))
    #             # store the variable at this ARG if we find it
    #             first_ARG_val = ep.args[first_EP_ARG]
    #         elif ep.predicate == second_EP:
    #             # if second_EP_ARG not a key in args dict, then the given ARG isn't in the EP
    #             self.assertIn(second_EP_ARG, ep.args, "{} is not an ARG of the EP {}:\n{}"
    #                           .format(second_EP_ARG, second_EP, ep.args[second_EP_ARG]))
    #             # store the variable at this ARG if we find it
    #             second_ARG_val = ep.args[second_EP_ARG]
    #
    #     # if we arrive here without setting the variables, then the EP wasn't in the RELS list at all
    #     self.assertIsNotNone(first_ARG_val, "{} is not an EP in RELS list:\n{}".format(
    #         first_EP, simplemrs.encode(generated_SEMENT_obj)))
    #     self.assertIsNotNone(second_ARG_val, "{} is not an EP in RELS list:\n{}".format(
    #         second_EP, simplemrs.encode(generated_SEMENT_obj)))
    #
    #     # create a set of the two variable values whose equality we are checking
    #     ARG_val_set = {first_ARG_val, second_ARG_val}
    #
    #     # make list of sets from eq tuples
    #     eq_sets = [set(eq) for eq in generated_SEMENT_obj.eqs]
    #
    #     # check if the set we created exist in the eqs, that is, are the variables we want to be equal actually
    #     # recorded as being equal in the eqs list?
    #     self.assertIn(ARG_val_set, eq_sets)

    def assertARGEquality(self, generated_SEMENT_obj, args_to_check):
        """
        Check that all the arguments in the list are identified with one another
        :param self:
        :param generated_SEMENT_obj:
        :param args_to_check: list of arguments
            {
                "EP_label": "_apple_n_1",
                "ARG": "ARG0",
            }
        """
        arg_eq_set = set()
        for arg in args_to_check:
            for rel in generated_SEMENT_obj.rels:
                #  if the pred_label on the current rel matches
                #  the current ARG in the args_to_check list we're looking at....
                if rel.predicate == arg["EP"]:
                    # add the variable value to the set of variables that should be identified
                    arg_eq_set.add(rel.args[arg["ARG"]])

        #






        # for eq in generated_SEMENT_obj.eqs:
        #     if first_ARG_val in eq and second_ARG_val in eq:


    def assertIsomorphic(self, generated_SEMENT_obj):
        """
        Assert SEMENT object generated by test is isomorphic to hand-validated SEMENT
        :param generated_SEMENT_obj:
        :return:
        """
        self.assertTrue(is_isomorphic(generated_SEMENT_obj, self.validated_SEMENT_obj),
                       "Generated SEMENT is not isomorphic to hand-validated SEMENT.\nGenerated: \n{}\n\nHand-Validated: \n{}"
                       .format(simplemrs.encode(generated_SEMENT_obj), self.validated_SEMENT_str))


    def tearDown(self):
        self.SEMENT_file.close()


    def test_basic(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/apple_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [ 
                INDEX: x1
                RELS: < [ _apple_n_1 LBL: h0 ARG0: x1 ] >
            ]
        """
        generated_SEMENT_obj = base.basic("_apple_n_1")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG0?
        self.assertINDEX(generated_SEMENT_obj, "ARG0")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)


    def test_adjective(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/red_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [ 
                INDEX: x2
                RELS: < [ _red_a_1 LBL: h0 ARG0: x1 ARG1: x2 ] >
            ]
        """
        generated_SEMENT_obj = base.adjective_SEMENT("_red_a_1")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG1?
        self.assertINDEX(generated_SEMENT_obj, "ARG1")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)


    def test_noun(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/apple_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [ 
                INDEX: x1
                RELS: < [ _apple_n_1 LBL: h0 ARG0: x1 ] >
            ]
        """
        generated_SEMENT_obj = base.noun_SEMENT("_apple_n_1")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG0?
        self.assertINDEX(generated_SEMENT_obj, "ARG0")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)

    def test_preposition(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/in_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [ INDEX: u2
              RELS: < [ _in_p_loc LBL: h0 ARG0: e1 ARG1: u2 ARG2: u3 ] >
            ]
        """
        generated_SEMENT_obj = base.preposition_SEMENT("_in_p_loc")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG1?
        self.assertINDEX(generated_SEMENT_obj, "ARG1")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)


    def test_quantifier(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/the_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [
                INDEX: x1
                RELS: < [ _the_q LBL: h0 ARG0: x1 RSTR: h2 BODY: h3 ] >
            ]
        """
        generated_SEMENT_obj = base.quant_SEMENT("_the_q")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG0?
        self.assertINDEX(generated_SEMENT_obj, "ARG0")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)


    def test_verb(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/sleep_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [
                INDEX: e1
                RELS: < [ _the_q LBL: h0 ARG0: e1 ARG1: i2 ] >
            ]
        """
        generated_SEMENT_obj = base.verb_SEMENT("_sleep_v_1")


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        # 2. Is the INDEX = ARG0?
        self.assertINDEX(generated_SEMENT_obj, "ARG0")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)

    # TODO: 02/12 PRONOUN TESTS...
    def test_pron_1st_sg(self):
        # ARRANGE: Call custom _setUp()
        self._setUp("hand_validated_SEMENT_strings/sleep_SEMENT.txt")


        # ACT: Generate SEMENT with sole adjectival EP
        """
            [
                INDEX: x1 { PERS: 1, NUM sg }
                RELS: <
                    [ pronoun_q LBL: h2  ARG0: x1 RSTR: h3 BODY: h4 ]
                    [ pron LBL: h0 ARG0: x1 ]
                >
                HCONS: < [ h3 qeq h4 ] >
            ]
        """
        generated_SEMENT_obj = base.pronoun_SEMENT({"PERS": "1", "NUM": "sg"})


        # ASSERT
        # 1. Is it a SEMENT object?
        self.assertSEMENTObject(generated_SEMENT_obj)

        pron_ARG0 = { "EP": "pron", "ARG": "ARG0" }
        pronoun_q_ARG0 = {"EP": "pronoun_q", "ARG": "ARG0"}
        self.assertARGEquality(generated_SEMENT_obj, [pron_ARG0, pronoun_q_ARG0])

        # 2. Is the INDEX = ARG0?
        self.assertINDEX(generated_SEMENT_obj, "ARG0")

        # 3. Is it isomorphic to the hand-validated MRS?
        self.assertIsomorphic(generated_SEMENT_obj)




if __name__ == '__main__':
    unittest.main()